"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _EventSpy = _interopRequireDefault(require("../EventSpy"));

var _FunctionContext = _interopRequireDefault(require("./FunctionContext"));

var _InternalContext = _interopRequireDefault(require("./InternalContext"));

var _SpineTo = _interopRequireDefault(require("../SpineTo"));

var _StateContext = _interopRequireDefault(require("./StateContext"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var MIN_CHECK_INTERVAL = 17; // 1 frame

var MODE_BOTTOM = 'bottom';
var MODE_TOP = 'top';
var NEAR_END_THRESHOLD = 1;
var SCROLL_DECISION_DURATION = 34; // 2 frames

function setImmediateInterval(fn, ms) {
  fn();
  return setInterval(fn, ms);
}

function computeViewState(_ref) {
  var mode = _ref.mode,
      _ref$target = _ref.target,
      offsetHeight = _ref$target.offsetHeight,
      scrollHeight = _ref$target.scrollHeight,
      scrollTop = _ref$target.scrollTop;
  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;
  var atTop = scrollTop < NEAR_END_THRESHOLD;
  var atEnd = mode === MODE_TOP ? atTop : atBottom;
  var atStart = mode !== MODE_TOP ? atTop : atBottom;
  return {
    atBottom: atBottom,
    atEnd: atEnd,
    atStart: atStart,
    atTop: atTop
  };
}

var Composer = function Composer(_ref2) {
  var checkInterval = _ref2.checkInterval,
      children = _ref2.children,
      debounce = _ref2.debounce,
      mode = _ref2.mode;
  mode = mode === MODE_TOP ? MODE_TOP : MODE_BOTTOM;
  var ignoreScrollEventBeforeRef = (0, _react.useRef)(0);

  var _useState = (0, _react.useState)(mode === MODE_TOP ? 0 : '100%'),
      _useState2 = _slicedToArray(_useState, 2),
      scrollTop = _useState2[0],
      setScrollTop = _useState2[1]; // Internal context


  var _useState3 = (0, _react.useState)(0),
      _useState4 = _slicedToArray(_useState3, 2),
      offsetHeight = _useState4[0],
      setOffsetHeight = _useState4[1];

  var _useState5 = (0, _react.useState)(0),
      _useState6 = _slicedToArray(_useState5, 2),
      scrollHeight = _useState6[0],
      setScrollHeight = _useState6[1]; // State context


  var _useState7 = (0, _react.useState)(false),
      _useState8 = _slicedToArray(_useState7, 2),
      animating = _useState8[0],
      setAnimating = _useState8[1];

  var _useState9 = (0, _react.useState)(true),
      _useState10 = _slicedToArray(_useState9, 2),
      atBottom = _useState10[0],
      setAtBottom = _useState10[1];

  var _useState11 = (0, _react.useState)(true),
      _useState12 = _slicedToArray(_useState11, 2),
      atEnd = _useState12[0],
      setAtEnd = _useState12[1];

  var _useState13 = (0, _react.useState)(true),
      _useState14 = _slicedToArray(_useState13, 2),
      atTop = _useState14[0],
      setAtTop = _useState14[1];

  var _useState15 = (0, _react.useState)(false),
      _useState16 = _slicedToArray(_useState15, 2),
      atStart = _useState16[0],
      setAtStart = _useState16[1];

  var _useState17 = (0, _react.useState)(true),
      _useState18 = _slicedToArray(_useState17, 2),
      sticky = _useState18[0],
      setSticky = _useState18[1]; // Function context


  var scrollTo = (0, _react.useCallback)(function (scrollTop) {
    setAnimating(true);
    setScrollTop(scrollTop);
  }, [setAnimating, setScrollTop]);
  var scrollToBottom = (0, _react.useCallback)(function () {
    return scrollTo('100%');
  }, [scrollTo]);
  var scrollToTop = (0, _react.useCallback)(function () {
    return scrollTo(0);
  }, [scrollTo]);
  var scrollToEnd = (0, _react.useCallback)(function () {
    return mode === MODE_TOP ? scrollToTop() : scrollToBottom();
  }, [mode, scrollToBottom, scrollToTop]);
  var scrollToStart = (0, _react.useCallback)(function () {
    return mode === MODE_TOP ? scrollToBottom() : scrollToTop();
  }, [mode, scrollToBottom, scrollToTop]);

  var _useState19 = (0, _react.useState)(null),
      _useState20 = _slicedToArray(_useState19, 2),
      target = _useState20[0],
      setTarget = _useState20[1];

  (0, _react.useEffect)(function () {
    if (sticky) {
      var stickyButNotAtEndSince = false;
      var timeout = setImmediateInterval(function () {
        if (sticky && target && !computeViewState({
          mode: mode,
          target: target
        }).atEnd) {
          if (!stickyButNotAtEndSince) {
            stickyButNotAtEndSince = Date.now();
          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {
            // Quirks: In Firefox, after user scroll down, Firefox do two things:
            //         1. Set to a new "scrollTop"
            //         2. Fire "scroll" event
            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.
            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.
            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.
            !animating && scrollToEnd();
            stickyButNotAtEndSince = false;
          }
        } else {
          stickyButNotAtEndSince = false;
        }
      }, Math.max(MIN_CHECK_INTERVAL, checkInterval) || MIN_CHECK_INTERVAL);
      return function () {
        return clearInterval(timeout);
      };
    }
  }, [animating, checkInterval, mode, scrollToEnd, sticky, target]);
  var handleScroll = (0, _react.useCallback)(function (_ref3) {
    var timeStampLow = _ref3.timeStampLow;

    // Currently, there are no reliable way to check if the "scroll" event is trigger due to
    // user gesture, programmatic scrolling, or Chrome-synthesized "scroll" event to compensate size change.
    // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.
    if (timeStampLow <= ignoreScrollEventBeforeRef.current) {
      // Since we debounce "scroll" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).
      // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.
      // Thus, on a fast machine, adding elements super fast will lose the "stickiness".
      return;
    }

    if (target) {
      var _computeViewState = computeViewState({
        mode: mode,
        target: target
      }),
          _atBottom = _computeViewState.atBottom,
          _atEnd = _computeViewState.atEnd,
          _atStart = _computeViewState.atStart,
          _atTop = _computeViewState.atTop;

      setAtBottom(_atBottom);
      setAtEnd(_atEnd);
      setAtStart(_atStart);
      setAtTop(_atTop); // Chrome will emit "synthetic" scroll event if the container is resized or an element is added
      // We need to ignore these "synthetic" events
      // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)
      //        Nomatter how fast or slow the sequence is being presssed, it should still stick to the bottom

      var nextOffsetHeight = target.offsetHeight,
          nextScrollHeight = target.scrollHeight;
      var offsetHeightChanged = nextOffsetHeight !== offsetHeight;
      var scrollHeightChanged = nextScrollHeight !== scrollHeight;
      offsetHeightChanged && setOffsetHeight(nextOffsetHeight);
      scrollHeightChanged && setScrollHeight(nextScrollHeight); // Sticky means:
      // - If it is scrolled programatically, we are still in sticky mode
      // - If it is scrolled by the user, then sticky means if we are at the end
      // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome

      !offsetHeightChanged && !scrollHeightChanged && setSticky(animating || _atEnd); // If no scrollTop is set (not in programmatic scrolling mode), we should set "animating" to false
      // "animating" is used to calculate the "sticky" property

      scrollTop === null && setAnimating(false);
    }
  }, [animating, ignoreScrollEventBeforeRef, mode, offsetHeight, scrollHeight, scrollTop, setAnimating, setAtBottom, setAtEnd, setAtStart, setAtTop, setOffsetHeight, setScrollHeight, setSticky, target]);
  var handleScrollEnd = (0, _react.useCallback)(function () {
    ignoreScrollEventBeforeRef.current = Date.now();
    setAnimating(false);
    setScrollTop(null);
  }, [ignoreScrollEventBeforeRef, setScrollTop]);
  var internalContext = (0, _react.useMemo)(function () {
    return {
      offsetHeight: offsetHeight,
      scrollHeight: scrollHeight,
      setTarget: setTarget
    };
  }, [offsetHeight, scrollHeight, setTarget]);
  var stateContext = (0, _react.useMemo)(function () {
    return {
      animating: animating,
      atBottom: atBottom,
      atEnd: atEnd,
      atStart: atStart,
      atTop: atTop,
      mode: mode,
      sticky: sticky
    };
  }, [animating, atBottom, atEnd, atStart, atTop, mode, sticky]);
  var functionContext = (0, _react.useMemo)(function () {
    return {
      scrollTo: scrollTo,
      scrollToBottom: scrollToBottom,
      scrollToEnd: scrollToEnd,
      scrollToStart: scrollToStart,
      scrollToTop: scrollToTop
    };
  }, [scrollTo, scrollToBottom, scrollToEnd, scrollToStart, scrollToTop]);
  (0, _react.useEffect)(function () {
    // We need to update the "scrollHeight" value to latest when the user do a focus inside the box.
    //
    // This is because:
    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether "scrollHeight" value is latest or not.
    // - That code only run on "scroll" event.
    // - That means, on every "scroll" event, if the "scrollHeight" value is not latest, we will skip modifying the stickiness.
    // - That means, if the user "focus" to an element that cause the scroll view to scroll to the bottom, the user agent will fire "scroll" event.
    //   Since the "scrollHeight" is not latest value, this "scroll" event will be ignored and stickiness will not be modified.
    // - That means, if the user "focus" to a newly added element that is at the end of the scroll view, the "scroll to bottom" button will continue to show.
    //
    // Repro in Chrome:
    // 1. Fill up a scroll view
    // 2. Scroll up, the "scroll to bottom" button should show up
    // 3. Click "Add a button"
    // 4. Click on the scroll view (to pseudo-focus on it)
    // 5. Press TAB, the scroll view will be at the bottom
    //
    // Expect:
    // - The "scroll to bottom" button should be gone.
    if (target) {
      var handleFocus = function handleFocus() {
        return setScrollHeight(target.scrollHeight);
      };

      target.addEventListener('focus', handleFocus, {
        capture: true,
        passive: true
      });
      return function () {
        return target.removeEventListener('focus', handleFocus);
      };
    }
  }, [target]);
  return /*#__PURE__*/_react.default.createElement(_InternalContext.default.Provider, {
    value: internalContext
  }, /*#__PURE__*/_react.default.createElement(_FunctionContext.default.Provider, {
    value: functionContext
  }, /*#__PURE__*/_react.default.createElement(_StateContext.default.Provider, {
    value: stateContext
  }, children, target && /*#__PURE__*/_react.default.createElement(_EventSpy.default, {
    debounce: debounce,
    name: "scroll",
    onEvent: handleScroll,
    target: target
  }), target && scrollTop !== null && /*#__PURE__*/_react.default.createElement(_SpineTo.default, {
    name: "scrollTop",
    onEnd: handleScrollEnd,
    target: target,
    value: scrollTop
  }))));
};

Composer.defaultProps = {
  checkInterval: 100,
  children: undefined,
  debounce: 17,
  mode: undefined
};
Composer.propTypes = {
  checkInterval: _propTypes.default.number,
  children: _propTypes.default.any,
  debounce: _propTypes.default.number,
  mode: _propTypes.default.oneOf(['bottom', 'top'])
};
var _default = Composer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9TY3JvbGxUb0JvdHRvbS9Db21wb3Nlci5qcyJdLCJuYW1lcyI6WyJNSU5fQ0hFQ0tfSU5URVJWQUwiLCJNT0RFX0JPVFRPTSIsIk1PREVfVE9QIiwiTkVBUl9FTkRfVEhSRVNIT0xEIiwiU0NST0xMX0RFQ0lTSU9OX0RVUkFUSU9OIiwic2V0SW1tZWRpYXRlSW50ZXJ2YWwiLCJmbiIsIm1zIiwic2V0SW50ZXJ2YWwiLCJjb21wdXRlVmlld1N0YXRlIiwibW9kZSIsInRhcmdldCIsIm9mZnNldEhlaWdodCIsInNjcm9sbEhlaWdodCIsInNjcm9sbFRvcCIsImF0Qm90dG9tIiwiYXRUb3AiLCJhdEVuZCIsImF0U3RhcnQiLCJDb21wb3NlciIsImNoZWNrSW50ZXJ2YWwiLCJjaGlsZHJlbiIsImRlYm91bmNlIiwiaWdub3JlU2Nyb2xsRXZlbnRCZWZvcmVSZWYiLCJzZXRTY3JvbGxUb3AiLCJzZXRPZmZzZXRIZWlnaHQiLCJzZXRTY3JvbGxIZWlnaHQiLCJhbmltYXRpbmciLCJzZXRBbmltYXRpbmciLCJzZXRBdEJvdHRvbSIsInNldEF0RW5kIiwic2V0QXRUb3AiLCJzZXRBdFN0YXJ0Iiwic3RpY2t5Iiwic2V0U3RpY2t5Iiwic2Nyb2xsVG8iLCJzY3JvbGxUb0JvdHRvbSIsInNjcm9sbFRvVG9wIiwic2Nyb2xsVG9FbmQiLCJzY3JvbGxUb1N0YXJ0Iiwic2V0VGFyZ2V0Iiwic3RpY2t5QnV0Tm90QXRFbmRTaW5jZSIsInRpbWVvdXQiLCJEYXRlIiwibm93IiwiTWF0aCIsIm1heCIsImNsZWFySW50ZXJ2YWwiLCJoYW5kbGVTY3JvbGwiLCJ0aW1lU3RhbXBMb3ciLCJjdXJyZW50IiwibmV4dE9mZnNldEhlaWdodCIsIm5leHRTY3JvbGxIZWlnaHQiLCJvZmZzZXRIZWlnaHRDaGFuZ2VkIiwic2Nyb2xsSGVpZ2h0Q2hhbmdlZCIsImhhbmRsZVNjcm9sbEVuZCIsImludGVybmFsQ29udGV4dCIsInN0YXRlQ29udGV4dCIsImZ1bmN0aW9uQ29udGV4dCIsImhhbmRsZUZvY3VzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhcHR1cmUiLCJwYXNzaXZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlZmF1bHRQcm9wcyIsInVuZGVmaW5lZCIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIm51bWJlciIsImFueSIsIm9uZU9mIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxrQkFBa0IsR0FBRyxFQUEzQixDLENBQStCOztBQUMvQixJQUFNQyxXQUFXLEdBQUcsUUFBcEI7QUFDQSxJQUFNQyxRQUFRLEdBQUcsS0FBakI7QUFDQSxJQUFNQyxrQkFBa0IsR0FBRyxDQUEzQjtBQUNBLElBQU1DLHdCQUF3QixHQUFHLEVBQWpDLEMsQ0FBcUM7O0FBRXJDLFNBQVNDLG9CQUFULENBQThCQyxFQUE5QixFQUFrQ0MsRUFBbEMsRUFBc0M7QUFDcENELEVBQUFBLEVBQUU7QUFFRixTQUFPRSxXQUFXLENBQUNGLEVBQUQsRUFBS0MsRUFBTCxDQUFsQjtBQUNEOztBQUVELFNBQVNFLGdCQUFULE9BQXVGO0FBQUEsTUFBM0RDLElBQTJELFFBQTNEQSxJQUEyRDtBQUFBLHlCQUFyREMsTUFBcUQ7QUFBQSxNQUEzQ0MsWUFBMkMsZUFBM0NBLFlBQTJDO0FBQUEsTUFBN0JDLFlBQTZCLGVBQTdCQSxZQUE2QjtBQUFBLE1BQWZDLFNBQWUsZUFBZkEsU0FBZTtBQUNyRixNQUFNQyxRQUFRLEdBQUdGLFlBQVksR0FBR0MsU0FBZixHQUEyQkYsWUFBM0IsR0FBMENULGtCQUEzRDtBQUNBLE1BQU1hLEtBQUssR0FBR0YsU0FBUyxHQUFHWCxrQkFBMUI7QUFDQSxNQUFNYyxLQUFLLEdBQUdQLElBQUksS0FBS1IsUUFBVCxHQUFvQmMsS0FBcEIsR0FBNEJELFFBQTFDO0FBQ0EsTUFBTUcsT0FBTyxHQUFHUixJQUFJLEtBQUtSLFFBQVQsR0FBb0JjLEtBQXBCLEdB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QU9lbkQsUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEV2ZW50U3B5IGZyb20gJy4uL0V2ZW50U3B5JztcbmltcG9ydCBGdW5jdGlvbkNvbnRleHQgZnJvbSAnLi9GdW5jdGlvbkNvbnRleHQnO1xuaW1wb3J0IEludGVybmFsQ29udGV4dCBmcm9tICcuL0ludGVybmFsQ29udGV4dCc7XG5pbXBvcnQgU3BpbmVUbyBmcm9tICcuLi9TcGluZVRvJztcbmltcG9ydCBTdGF0ZUNvbnRleHQgZnJvbSAnLi9TdGF0ZUNvbnRleHQnO1xuXG5jb25zdCBNSU5fQ0hFQ0tfSU5URVJWQUwgPSAxNzsgLy8gMSBmcmFtZVxuY29uc3QgTU9ERV9CT1RUT00gPSAnYm90dG9tJztcbmNvbnN0IE1PREVfVE9QID0gJ3RvcCc7XG5jb25zdCBORUFSX0VORF9USFJFU0hPTEQgPSAxO1xuY29uc3QgU0NST0xMX0RFQ0lTSU9OX0RVUkFUSU9OID0gMzQ7IC8vIDIgZnJhbWVzXG5cbmZ1bmN0aW9uIHNldEltbWVkaWF0ZUludGVydmFsKGZuLCBtcykge1xuICBmbigpO1xuXG4gIHJldHVybiBzZXRJbnRlcnZhbChmbiwgbXMpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlVmlld1N0YXRlKHsgbW9kZSwgdGFyZ2V0OiB7IG9mZnNldEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBzY3JvbGxUb3AgfSB9KSB7XG4gIGNvbnN0IGF0Qm90dG9tID0gc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsVG9wIC0gb2Zmc2V0SGVpZ2h0IDwgTkVBUl9FTkRfVEhSRVNIT0xEO1xuICBjb25zdCBhdFRvcCA9IHNjcm9sbFRvcCA8IE5FQVJfRU5EX1RIUkVTSE9MRDtcbiAgY29uc3QgYXRFbmQgPSBtb2RlID09PSBNT0RFX1RPUCA/IGF0VG9wIDogYXRCb3R0b207XG4gIGNvbnN0IGF0U3RhcnQgPSBtb2RlICE9PSBNT0RFX1RPUCA/IGF0VG9wIDogYXRCb3R0b207XG5cbiAgcmV0dXJuIHtcbiAgICBhdEJvdHRvbSxcbiAgICBhdEVuZCxcbiAgICBhdFN0YXJ0LFxuICAgIGF0VG9wXG4gIH07XG59XG5cbmNvbnN0IENvbXBvc2VyID0gKHsgY2hlY2tJbnRlcnZhbCwgY2hpbGRyZW4sIGRlYm91bmNlLCBtb2RlIH0pID0+IHtcbiAgbW9kZSA9IG1vZGUgPT09IE1PREVfVE9QID8gTU9ERV9UT1AgOiBNT0RFX0JPVFRPTTtcblxuICBjb25zdCBpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZiA9IHVzZVJlZigwKTtcbiAgY29uc3QgW3Njcm9sbFRvcCwgc2V0U2Nyb2xsVG9wXSA9IHVzZVN0YXRlKG1vZGUgPT09IE1PREVfVE9QID8gMCA6ICcxMDAlJyk7XG5cbiAgLy8gSW50ZXJuYWwgY29udGV4dFxuICBjb25zdCBbb2Zmc2V0SGVpZ2h0LCBzZXRPZmZzZXRIZWlnaHRdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtzY3JvbGxIZWlnaHQsIHNldFNjcm9sbEhlaWdodF0gPSB1c2VTdGF0ZSgwKTtcblxuICAvLyBTdGF0ZSBjb250ZXh0XG4gIGNvbnN0IFthbmltYXRpbmcsIHNldEFuaW1hdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFthdEJvdHRvbSwgc2V0QXRCb3R0b21dID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFthdEVuZCwgc2V0QXRFbmRdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFthdFRvcCwgc2V0QXRUb3BdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFthdFN0YXJ0LCBzZXRBdFN0YXJ0XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3N0aWNreSwgc2V0U3RpY2t5XSA9IHVzZVN0YXRlKHRydWUpO1xuXG4gIC8vIEZ1bmN0aW9uIGNvbnRleHRcbiAgY29uc3Qgc2Nyb2xsVG8gPSB1c2VDYWxsYmFjayhcbiAgICBzY3JvbGxUb3AgPT4ge1xuICAgICAgc2V0QW5pbWF0aW5nKHRydWUpO1xuICAgICAgc2V0U2Nyb2xsVG9wKHNjcm9sbFRvcCk7XG4gICAgfSxcbiAgICBbc2V0QW5pbWF0aW5nLCBzZXRTY3JvbGxUb3BdXG4gICk7XG5cbiAgY29uc3Qgc2Nyb2xsVG9Cb3R0b20gPSB1c2VDYWxsYmFjaygoKSA9PiBzY3JvbGxUbygnMTAwJScpLCBbc2Nyb2xsVG9dKTtcbiAgY29uc3Qgc2Nyb2xsVG9Ub3AgPSB1c2VDYWxsYmFjaygoKSA9PiBzY3JvbGxUbygwKSwgW3Njcm9sbFRvXSk7XG5cbiAgY29uc3Qgc2Nyb2xsVG9FbmQgPSB1c2VDYWxsYmFjaygoKSA9PiAobW9kZSA9PT0gTU9ERV9UT1AgPyBzY3JvbGxUb1RvcCgpIDogc2Nyb2xsVG9Cb3R0b20oKSksIFtcbiAgICBtb2RlLFxuICAgIHNjcm9sbFRvQm90dG9tLFxuICAgIHNjcm9sbFRvVG9wXG4gIF0pO1xuICBjb25zdCBzY3JvbGxUb1N0YXJ0ID0gdXNlQ2FsbGJhY2soKCkgPT4gKG1vZGUgPT09IE1PREVfVE9QID8gc2Nyb2xsVG9Cb3R0b20oKSA6IHNjcm9sbFRvVG9wKCkpLCBbXG4gICAgbW9kZSxcbiAgICBzY3JvbGxUb0JvdHRvbSxcbiAgICBzY3JvbGxUb1RvcFxuICBdKTtcblxuICBjb25zdCBbdGFyZ2V0LCBzZXRUYXJnZXRdID0gdXNlU3RhdGUobnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBsZXQgc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA9IGZhbHNlO1xuXG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0SW1tZWRpYXRlSW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAoc3RpY2t5ICYmIHRhcmdldCAmJiAhY29tcHV0ZVZpZXdTdGF0ZSh7IG1vZGUsIHRhcmdldCB9KS5hdEVuZCkge1xuICAgICAgICAgIGlmICghc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSkge1xuICAgICAgICAgICAgc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChEYXRlLm5vdygpIC0gc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA+IFNDUk9MTF9ERUNJU0lPTl9EVVJBVElPTikge1xuICAgICAgICAgICAgLy8gUXVpcmtzOiBJbiBGaXJlZm94LCBhZnRlciB1c2VyIHNjcm9sbCBkb3duLCBGaXJlZm94IGRvIHR3byB0aGluZ3M6XG4gICAgICAgICAgICAvLyAgICAgICAgIDEuIFNldCB0byBhIG5ldyBcInNjcm9sbFRvcFwiXG4gICAgICAgICAgICAvLyAgICAgICAgIDIuIEZpcmUgXCJzY3JvbGxcIiBldmVudFxuICAgICAgICAgICAgLy8gICAgICAgICBGb3Igd2hhdCB3ZSBvYnNlcnZlZCwgIzEgaXMgZmlyZWQgYWJvdXQgMjBtcyBiZWZvcmUgIzIuIFRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgdGhpcyBzdGlja3lDaGVja1RpbWVvdXQgaXMgYmVpbmcgc2NoZWR1bGVkIGJldHdlZW4gMSBhbmQgMi5cbiAgICAgICAgICAgIC8vICAgICAgICAgVGhhdCBtZWFucywgaWYgd2UganVzdCBsb29rIGF0ICMxIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgc2Nyb2xsLCB3ZSB3aWxsIGFsd2F5cyBzY3JvbGwsIGluIG9wcG9zZSB0byB0aGUgdXNlcidzIGludGVudGlvbi5cbiAgICAgICAgICAgIC8vIFJlcHJvOiBPcGVuIEZpcmVmb3gsIHNldCBjaGVja0ludGVydmFsIHRvIGEgbG93ZXIgbnVtYmVyLCBhbmQgdHJ5IHRvIHNjcm9sbCBieSBkcmFnZ2luZyB0aGUgc2Nyb2xsIGhhbmRsZXIuIEl0IHdpbGwganVtcCBiYWNrLlxuXG4gICAgICAgICAgICAhYW5pbWF0aW5nICYmIHNjcm9sbFRvRW5kKCk7XG4gICAgICAgICAgICBzdGlja3lCdXROb3RBdEVuZFNpbmNlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0aWNreUJ1dE5vdEF0RW5kU2luY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5tYXgoTUlOX0NIRUNLX0lOVEVSVkFMLCBjaGVja0ludGVydmFsKSB8fCBNSU5fQ0hFQ0tfSU5URVJWQUwpO1xuXG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbCh0aW1lb3V0KTtcbiAgICB9XG4gIH0sIFthbmltYXRpbmcsIGNoZWNrSW50ZXJ2YWwsIG1vZGUsIHNjcm9sbFRvRW5kLCBzdGlja3ksIHRhcmdldF0pO1xuXG4gIGNvbnN0IGhhbmRsZVNjcm9sbCA9IHVzZUNhbGxiYWNrKFxuICAgICh7IHRpbWVTdGFtcExvdyB9KSA9PiB7XG4gICAgICAvLyBDdXJyZW50bHksIHRoZXJlIGFyZSBubyByZWxpYWJsZSB3YXkgdG8gY2hlY2sgaWYgdGhlIFwic2Nyb2xsXCIgZXZlbnQgaXMgdHJpZ2dlciBkdWUgdG9cbiAgICAgIC8vIHVzZXIgZ2VzdHVyZSwgcHJvZ3JhbW1hdGljIHNjcm9sbGluZywgb3IgQ2hyb21lLXN5bnRoZXNpemVkIFwic2Nyb2xsXCIgZXZlbnQgdG8gY29tcGVuc2F0ZSBzaXplIGNoYW5nZS5cbiAgICAgIC8vIFRodXMsIHdlIHVzZSBvdXIgYmVzdC1lZmZvcnQgdG8gZ3Vlc3MgaWYgaXQgaXMgdHJpZ2dlcmVkIGJ5IHVzZXIgZ2VzdHVyZSwgYW5kIGRpc2FibGUgc3RpY2t5IGlmIGl0IGlzIGhlYWRpbmcgdG93YXJkcyB0aGUgc3RhcnQgZGlyZWN0aW9uLlxuXG4gICAgICBpZiAodGltZVN0YW1wTG93IDw9IGlnbm9yZVNjcm9sbEV2ZW50QmVmb3JlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gU2luY2Ugd2UgZGVib3VuY2UgXCJzY3JvbGxcIiBldmVudCwgdGhpcyBoYW5kbGVyIG1pZ2h0IGJlIGNhbGxlZCBhZnRlciBzcGluZVRvLm9uRW5kIChhLmsuYS4gYXJ0aWZpY2lhbCBzY3JvbGxpbmcpLlxuICAgICAgICAvLyBXZSBzaG91bGQgaWdub3JlIGRlYm91bmNlZCBldmVudCBmaXJlZCBhZnRlciBzY3JvbGxFbmQsIGJlY2F1c2Ugd2l0aG91dCBza2lwcGluZyB0aGVtLCB0aGUgdXNlckluaXRpYXRlZFNjcm9sbCBjYWxjdWxhdGVkIGJlbG93IHdpbGwgbm90IGJlIGFjY3VyYXRlLlxuICAgICAgICAvLyBUaHVzLCBvbiBhIGZhc3QgbWFjaGluZSwgYWRkaW5nIGVsZW1lbnRzIHN1cGVyIGZhc3Qgd2lsbCBsb3NlIHRoZSBcInN0aWNraW5lc3NcIi5cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgeyBhdEJvdHRvbSwgYXRFbmQsIGF0U3RhcnQsIGF0VG9wIH0gPSBjb21wdXRlVmlld1N0YXRlKHsgbW9kZSwgdGFyZ2V0IH0pO1xuXG4gICAgICAgIHNldEF0Qm90dG9tKGF0Qm90dG9tKTtcbiAgICAgICAgc2V0QXRFbmQoYXRFbmQpO1xuICAgICAgICBzZXRBdFN0YXJ0KGF0U3RhcnQpO1xuICAgICAgICBzZXRBdFRvcChhdFRvcCk7XG5cbiAgICAgICAgLy8gQ2hyb21lIHdpbGwgZW1pdCBcInN5bnRoZXRpY1wiIHNjcm9sbCBldmVudCBpZiB0aGUgY29udGFpbmVyIGlzIHJlc2l6ZWQgb3IgYW4gZWxlbWVudCBpcyBhZGRlZFxuICAgICAgICAvLyBXZSBuZWVkIHRvIGlnbm9yZSB0aGVzZSBcInN5bnRoZXRpY1wiIGV2ZW50c1xuICAgICAgICAvLyBSZXBybzogSW4gcGxheWdyb3VuZCwgcHJlc3MgNC0xLTUtMS0xIChzbWFsbCwgYWRkIG9uZSwgbm9ybWFsLCBhZGQgb25lLCBhZGQgb25lKVxuICAgICAgICAvLyAgICAgICAgTm9tYXR0ZXIgaG93IGZhc3Qgb3Igc2xvdyB0aGUgc2VxdWVuY2UgaXMgYmVpbmcgcHJlc3NzZWQsIGl0IHNob3VsZCBzdGlsbCBzdGljayB0byB0aGUgYm90dG9tXG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0SGVpZ2h0OiBuZXh0T2Zmc2V0SGVpZ2h0LCBzY3JvbGxIZWlnaHQ6IG5leHRTY3JvbGxIZWlnaHQgfSA9IHRhcmdldDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0SGVpZ2h0Q2hhbmdlZCA9IG5leHRPZmZzZXRIZWlnaHQgIT09IG9mZnNldEhlaWdodDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsSGVpZ2h0Q2hhbmdlZCA9IG5leHRTY3JvbGxIZWlnaHQgIT09IHNjcm9sbEhlaWdodDtcblxuICAgICAgICBvZmZzZXRIZWlnaHRDaGFuZ2VkICYmIHNldE9mZnNldEhlaWdodChuZXh0T2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgc2Nyb2xsSGVpZ2h0Q2hhbmdlZCAmJiBzZXRTY3JvbGxIZWlnaHQobmV4dFNjcm9sbEhlaWdodCk7XG5cbiAgICAgICAgLy8gU3RpY2t5IG1lYW5zOlxuICAgICAgICAvLyAtIElmIGl0IGlzIHNjcm9sbGVkIHByb2dyYW1hdGljYWxseSwgd2UgYXJlIHN0aWxsIGluIHN0aWNreSBtb2RlXG4gICAgICAgIC8vIC0gSWYgaXQgaXMgc2Nyb2xsZWQgYnkgdGhlIHVzZXIsIHRoZW4gc3RpY2t5IG1lYW5zIGlmIHdlIGFyZSBhdCB0aGUgZW5kXG5cbiAgICAgICAgLy8gT25seSB1cGRhdGUgc3RpY2tpbmVzcyBpZiB0aGUgc2Nyb2xsIGV2ZW50IGlzIG5vdCBkdWUgdG8gc3ludGhldGljIHNjcm9sbCBkb25lIGJ5IENocm9tZVxuICAgICAgICAhb2Zmc2V0SGVpZ2h0Q2hhbmdlZCAmJiAhc2Nyb2xsSGVpZ2h0Q2hhbmdlZCAmJiBzZXRTdGlja3koYW5pbWF0aW5nIHx8IGF0RW5kKTtcblxuICAgICAgICAvLyBJZiBubyBzY3JvbGxUb3AgaXMgc2V0IChub3QgaW4gcHJvZ3JhbW1hdGljIHNjcm9sbGluZyBtb2RlKSwgd2Ugc2hvdWxkIHNldCBcImFuaW1hdGluZ1wiIHRvIGZhbHNlXG4gICAgICAgIC8vIFwiYW5pbWF0aW5nXCIgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIFwic3RpY2t5XCIgcHJvcGVydHlcbiAgICAgICAgc2Nyb2xsVG9wID09PSBudWxsICYmIHNldEFuaW1hdGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBhbmltYXRpbmcsXG4gICAgICBpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZixcbiAgICAgIG1vZGUsXG4gICAgICBvZmZzZXRIZWlnaHQsXG4gICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxUb3AsXG4gICAgICBzZXRBbmltYXRpbmcsXG4gICAgICBzZXRBdEJvdHRvbSxcbiAgICAgIHNldEF0RW5kLFxuICAgICAgc2V0QXRTdGFydCxcbiAgICAgIHNldEF0VG9wLFxuICAgICAgc2V0T2Zmc2V0SGVpZ2h0LFxuICAgICAgc2V0U2Nyb2xsSGVpZ2h0LFxuICAgICAgc2V0U3RpY2t5LFxuICAgICAgdGFyZ2V0XG4gICAgXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZVNjcm9sbEVuZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZi5jdXJyZW50ID0gRGF0ZS5ub3coKTtcbiAgICBzZXRBbmltYXRpbmcoZmFsc2UpO1xuICAgIHNldFNjcm9sbFRvcChudWxsKTtcbiAgfSwgW2lnbm9yZVNjcm9sbEV2ZW50QmVmb3JlUmVmLCBzZXRTY3JvbGxUb3BdKTtcblxuICBjb25zdCBpbnRlcm5hbENvbnRleHQgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBvZmZzZXRIZWlnaHQsXG4gICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICBzZXRUYXJnZXRcbiAgICB9KSxcbiAgICBbb2Zmc2V0SGVpZ2h0LCBzY3JvbGxIZWlnaHQsIHNldFRhcmdldF1cbiAgKTtcblxuICBjb25zdCBzdGF0ZUNvbnRleHQgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBhbmltYXRpbmcsXG4gICAgICBhdEJvdHRvbSxcbiAgICAgIGF0RW5kLFxuICAgICAgYXRTdGFydCxcbiAgICAgIGF0VG9wLFxuICAgICAgbW9kZSxcbiAgICAgIHN0aWNreVxuICAgIH0pLFxuICAgIFthbmltYXRpbmcsIGF0Qm90dG9tLCBhdEVuZCwgYXRTdGFydCwgYXRUb3AsIG1vZGUsIHN0aWNreV1cbiAgKTtcblxuICBjb25zdCBmdW5jdGlvbkNvbnRleHQgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBzY3JvbGxUbyxcbiAgICAgIHNjcm9sbFRvQm90dG9tLFxuICAgICAgc2Nyb2xsVG9FbmQsXG4gICAgICBzY3JvbGxUb1N0YXJ0LFxuICAgICAgc2Nyb2xsVG9Ub3BcbiAgICB9KSxcbiAgICBbc2Nyb2xsVG8sIHNjcm9sbFRvQm90dG9tLCBzY3JvbGxUb0VuZCwgc2Nyb2xsVG9TdGFydCwgc2Nyb2xsVG9Ub3BdXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBXZSBuZWVkIHRvIHVwZGF0ZSB0aGUgXCJzY3JvbGxIZWlnaHRcIiB2YWx1ZSB0byBsYXRlc3Qgd2hlbiB0aGUgdXNlciBkbyBhIGZvY3VzIGluc2lkZSB0aGUgYm94LlxuICAgIC8vXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlOlxuICAgIC8vIC0gSW4gb3VyIGNvZGUgdGhhdCBtaXRpZ2F0ZSBDaHJvbWUgc3ludGhldGljIHNjcm9sbGluZywgdGhhdCBjb2RlIHdpbGwgbG9vayBhdCB3aGV0aGVyIFwic2Nyb2xsSGVpZ2h0XCIgdmFsdWUgaXMgbGF0ZXN0IG9yIG5vdC5cbiAgICAvLyAtIFRoYXQgY29kZSBvbmx5IHJ1biBvbiBcInNjcm9sbFwiIGV2ZW50LlxuICAgIC8vIC0gVGhhdCBtZWFucywgb24gZXZlcnkgXCJzY3JvbGxcIiBldmVudCwgaWYgdGhlIFwic2Nyb2xsSGVpZ2h0XCIgdmFsdWUgaXMgbm90IGxhdGVzdCwgd2Ugd2lsbCBza2lwIG1vZGlmeWluZyB0aGUgc3RpY2tpbmVzcy5cbiAgICAvLyAtIFRoYXQgbWVhbnMsIGlmIHRoZSB1c2VyIFwiZm9jdXNcIiB0byBhbiBlbGVtZW50IHRoYXQgY2F1c2UgdGhlIHNjcm9sbCB2aWV3IHRvIHNjcm9sbCB0byB0aGUgYm90dG9tLCB0aGUgdXNlciBhZ2VudCB3aWxsIGZpcmUgXCJzY3JvbGxcIiBldmVudC5cbiAgICAvLyAgIFNpbmNlIHRoZSBcInNjcm9sbEhlaWdodFwiIGlzIG5vdCBsYXRlc3QgdmFsdWUsIHRoaXMgXCJzY3JvbGxcIiBldmVudCB3aWxsIGJlIGlnbm9yZWQgYW5kIHN0aWNraW5lc3Mgd2lsbCBub3QgYmUgbW9kaWZpZWQuXG4gICAgLy8gLSBUaGF0IG1lYW5zLCBpZiB0aGUgdXNlciBcImZvY3VzXCIgdG8gYSBuZXdseSBhZGRlZCBlbGVtZW50IHRoYXQgaXMgYXQgdGhlIGVuZCBvZiB0aGUgc2Nyb2xsIHZpZXcsIHRoZSBcInNjcm9sbCB0byBib3R0b21cIiBidXR0b24gd2lsbCBjb250aW51ZSB0byBzaG93LlxuICAgIC8vXG4gICAgLy8gUmVwcm8gaW4gQ2hyb21lOlxuICAgIC8vIDEuIEZpbGwgdXAgYSBzY3JvbGwgdmlld1xuICAgIC8vIDIuIFNjcm9sbCB1cCwgdGhlIFwic2Nyb2xsIHRvIGJvdHRvbVwiIGJ1dHRvbiBzaG91bGQgc2hvdyB1cFxuICAgIC8vIDMuIENsaWNrIFwiQWRkIGEgYnV0dG9uXCJcbiAgICAvLyA0LiBDbGljayBvbiB0aGUgc2Nyb2xsIHZpZXcgKHRvIHBzZXVkby1mb2N1cyBvbiBpdClcbiAgICAvLyA1LiBQcmVzcyBUQUIsIHRoZSBzY3JvbGwgdmlldyB3aWxsIGJlIGF0IHRoZSBib3R0b21cbiAgICAvL1xuICAgIC8vIEV4cGVjdDpcbiAgICAvLyAtIFRoZSBcInNjcm9sbCB0byBib3R0b21cIiBidXR0b24gc2hvdWxkIGJlIGdvbmUuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgY29uc3QgaGFuZGxlRm9jdXMgPSAoKSA9PiBzZXRTY3JvbGxIZWlnaHQodGFyZ2V0LnNjcm9sbEhlaWdodCk7XG5cbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZUZvY3VzLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBoYW5kbGVGb2N1cyk7XG4gICAgfVxuICB9LCBbdGFyZ2V0XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8SW50ZXJuYWxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbnRlcm5hbENvbnRleHR9PlxuICAgICAgPEZ1bmN0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17ZnVuY3Rpb25Db250ZXh0fT5cbiAgICAgICAgPFN0YXRlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17c3RhdGVDb250ZXh0fT5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAge3RhcmdldCAmJiA8RXZlbnRTcHkgZGVib3VuY2U9e2RlYm91bmNlfSBuYW1lPVwic2Nyb2xsXCIgb25FdmVudD17aGFuZGxlU2Nyb2xsfSB0YXJnZXQ9e3RhcmdldH0gLz59XG4gICAgICAgICAge3RhcmdldCAmJiBzY3JvbGxUb3AgIT09IG51bGwgJiYgKFxuICAgICAgICAgICAgPFNwaW5lVG8gbmFtZT1cInNjcm9sbFRvcFwiIG9uRW5kPXtoYW5kbGVTY3JvbGxFbmR9IHRhcmdldD17dGFyZ2V0fSB2YWx1ZT17c2Nyb2xsVG9wfSAvPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvU3RhdGVDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgPC9GdW5jdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICAgPC9JbnRlcm5hbENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5Db21wb3Nlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGNoZWNrSW50ZXJ2YWw6IDEwMCxcbiAgY2hpbGRyZW46IHVuZGVmaW5lZCxcbiAgZGVib3VuY2U6IDE3LFxuICBtb2RlOiB1bmRlZmluZWRcbn07XG5cbkNvbXBvc2VyLnByb3BUeXBlcyA9IHtcbiAgY2hlY2tJbnRlcnZhbDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gIGRlYm91bmNlOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtb2RlOiBQcm9wVHlwZXMub25lT2YoWydib3R0b20nLCAndG9wJ10pXG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb21wb3NlcjtcbiJdfQ==